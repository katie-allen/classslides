---
title: "Strings & Joins"
author: ""
params:
  day: 10
  ptitle: true
  pbackground: true
  dtype: "none"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

if (params$day %% 2 == 0) md_intro_format <- "even_intro_format.Rmd"
if (params$day %% 2 == 1) md_intro_format <- "odd_intro_format.Rmd"

```

# Becoming the Critic {data-background=#e8d725}

```{r nextone}
vday <- params$day - 1
vlink <- paste0("http://www.perceptualedge.com/example", vday, ".php")
titlelink <- paste0('{data-background-iframe="', vlink, '"}')
```

## `r titlelink`

[Visualization of the Day](`r vlink`)


```{r child=md_intro_format}

```


# Male Heights {data-background=#e8d725}

## What did we learn about Male Heights (1)

**Height variations within a population are largely genetic, but height variations between populations are mostly environmental, anthropometric history suggests.**

> * If the average Norwegian is taller than the average Nigerian it's because Norwegians live healthier lives. That's why the United Nations now uses height to monitor nutrition in developing countries.

[New Yorker 2004](https://www.newyorker.com/magazine/2004/04/05/the-height-gap)

## What did we learn about Male Heights (2)

> * Yet in Northern Europe over the past twelve hundred years human stature has followed a U-shaped curve: from a high around 800 A.D., to a low sometime in the seventeenth century, and back up again.

[New Yorker 2004](https://www.newyorker.com/magazine/2004/04/05/the-height-gap)


# Relational Data and R {data-background=#e8d725}

## Defining Terms

<style type="text/css">
 span.bullet_code {
    color: black;
    font-weight: bold;
    background-color: white;
    
}
</style>

> - A <span class="bullet_code">**primary key**</span> uniquely identifies an observation in its own table. For example, <span class="bullet_code">planes$tailnum</span> is a primary key because it uniquely identifies each plane in the planes table.
> - A <span class="bullet_code">**foreign key**</span> provides the link between data in two tables. For example, the <span class="bullet_code">flights$tailnum</span> is a foreign key because it appears in the flights table where it matches each flight to a unique plane.
> - A **Left Join** is a mutating join.

## Relational Database review

Simple demo on the boards

## Work examples
Load the flights dataset
```{r echo=TRUE, eval=FALSE}
library(nycflights13)
```

Say I wanted to investigate a relationship between airplane age (contained in `planes`) of a plane and flight delays (`flights` table). Create the dataset that would allow you to make a simple plot to visualize the relationship

```{r eval=FALSE}
glimpse(planes)
planes%>% mutate(age = 2013-year) %>% right_join(flights) %>% glimpse() #purposefully leave it blank to point out the problem with year
planes%>% mutate(age = 2013-year) %>% right_join(flights, by="tailnum") %>% glimpse()
#what does x mean in the column names?
```


## Work examples(2): uncommon column names


We want to add lat and long data ( in `airports` table) for origin and destination airports in the `flights` table.

```{r eval=FALSE}
#add lat and long (airports) for origin and destination airports (flights)
glimpse(airports)
glimpse(flights)

left_join(flights, airports, by=c("origin" = "faa")) %>% 
  left_join(airports, by=c("dest" = "faa")) %>% 
  glimpse()
#What does .x and .y mean in the column names?
```


## Duplicate Keys

> - [One table w/ duplicates](http://r4ds.had.co.nz/diagrams/join-one-to-many.png)
> - [Both tables w/ duplicates](http://r4ds.had.co.nz/diagrams/join-many-to-many.png)

## Filtering joins

> - [Filtering joins](http://r4ds.had.co.nz/relational-data.html#filtering-joins) don't add columns. They are an efficient way to filter on multiple columns.
> - <span class="bullet_code">semi_join(x, y)</span> keeps all observations in x that have a match in y.
> - <span class="bullet_code">anti_join(x, y)</span> drops all observations in x that have a match in y.

## In-depth example

**Partner-up**: 1 is a problem solver and tells what to do. The other is the coder and codes up the solution.

> - For each tailnumber in planes datatable, you want to know which carrier is operating it.
> - *BONUS*: Include the carrier's full name (in `airlines`), not just the 2 digit abbreviation.


```{r echo = FALSE, eval = FALSE}
planes  %>% 
  left_join(flights, by = "tailnum") %>% 
  distinct(tailnum, carrier) %>% #If I stop here, there are a few duplicate tailnumbers, they were operated by multiple carriers. Because flights is sorted in chronological order, I just take the last (or most recent one) to remove the duplcates
  group_by(tailnum) %>% 
  summarise_all(last)  %>% #or I could have done slice(n())

#Now to get the full carrier's name
left_join(airlines)

```



## Other methods (merge())

`base::merge()` can perform all four types of joins:

dplyr              | merge
-------------------|-------------------------------------------
inner_join(x, y) | merge(x, y)
left_join(x, y)  | merge(x, y, all.x = TRUE)
right_join(x, y) | merge(x, y, all.y = TRUE),
full_join(x, y)  | merge(x, y, all.x = TRUE, all.y = TRUE)

<>
       
> - specific dplyr verbs more clearly convey the intent of your code: they are not concealed in the arguments of <span class="bullet_code">merge()</span>.
> - **dplyr's joins are considerably faster and don't mess with the order of the rows.**

## Other methods (SQL)

SQL is the inspiration for dplyr's conventions, so the translation is straightforward:

dplyr                        | SQL
-----------------------------|-------------------------------------------
inner_join(x, y, by = "z") | SELECT * FROM x INNER JOIN y USING (z)
left_join(x, y, by = "z")  | SELECT * FROM x LEFT OUTER JOIN y USING (z)
right_join(x, y, by = "z") | SELECT * FROM x RIGHT OUTER JOIN y USING (z)
full_join(x, y, by = "z")  | SELECT * FROM x FULL OUTER JOIN y USING (z)

<>

> - Note that "INNER" and "OUTER" are optional, and often omitted.
> - SQL supports a wider  range of join types than dplyr

# Next Thursday's Process {data-background=#e8d725}

## Background (Learning how to learn)

**Learning how to articulate good questions is strongly correlated with quality structured thinking**


<iframe width="760" height="415" src="https://www.youtube.com/embed/7w0mtaQ051g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

https://www.nbc.com/saturday-night-live/video/nick-burns-your-companys-computer-guy/n11355

## Thursday's Plan

The baseball joining task for Thursday is tricky and requires focus.

> 1. Those students that complete it before class will be placed in teams with other students that are having difficulties with the task.
> 2. Each group will need to work on their own to structure a plan to complete the task (Think [data flow diagrams](https://www.lucidchart.com/blog/data-flow-diagram-tutorial)).  
> 3. Vivian and I will be available for two 5-minute QA programming support for your team. We want your team to have carefully thought out the most optimal questions you need to ask to get you through your current unsolvable challenge.
>    a. Remember the [structured thinking point](https://www.analyticsvidhya.com/blog/2014/02/tools-structured-thinking/), don't waste the 5 minutes trying to explain the question. Take time to ensure I/Vivian can get up to speed quickly. 